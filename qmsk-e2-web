#!/usr/bin/env python3

import argparse
import asyncio
import logging; log = logging.getLogger('qmsk-e2-web')
import qmsk.cli
import qmsk.e2.client
import qmsk.e2.presets
import qmsk.e2.web
import qmsk.e2.websocket
import qmsk.net.tcp
import signal


class Server:
    def __init__ (self, loop):
        self.loop = loop

        self.client = None
        self.presets = None

    @asyncio.coroutine
    def start (self, args):
        try:
            self.client = yield from qmsk.e2.client.E2Client.connect(args.e2_host,
                    safe    = args.e2_safe,
            )
        except qmsk.net.tcp.Error as error:
            log.error("%s: failed to connect: %s", args.e2_host, error)
            return 1

        self.presets = qmsk.e2.presets.E2Presets.load(
            xml_dir     = args.e2_presets_xml,
            yaml_file   = args.e2_presets_yaml,
            db          = args.e2_presets_db,
        )

        if not self.presets.presets:
            log.error("no presets given")
            return 1
        
        self.web = yield from qmsk.e2.web.start(self.client, self.presets,
                loop    = self.loop,
                listen  = args.e2_web_listen,
                port    = args.e2_web_port,
                static  = {
                    '/static':  args.e2_web_static,
                },
        )

        self.websocket = yield from qmsk.e2.websocket.start(self.presets,
                loop    = self.loop,
                listen  = args.e2_web_listen,
                port    = args.e2_websocket_port,
        )

    @asyncio.coroutine
    def stop (self):
        self.presets.close()
        self.websocket.stop()

def signal_stop (server):
    """
        Stop event loop gracefully on signal.
    """

    loop = asyncio.get_event_loop()

    # tell our Server to stop
    log.info("signalling server stop...")
    do_stop = asyncio.async(server.stop(), loop=loop)

    def _stop (do_stop):
        log.info("stopping event loop...")

        # this will ignore any new callbacks added, and cause the loop.run_forever() in main to return
        loop.stop()

    # once stopped, wind down the event loop
    do_stop.add_done_callback(_stop)


def main (argv):
    parser = qmsk.cli.parser()
    parser.add_argument('--e2-host', metavar='HOST',
        help="Encore2 host address")
    parser.add_argument('--e2-safe', action='store_true',
        help="Encore2 safe mode")
    parser.add_argument('--e2-web-listen', metavar='ADDR',
        help="Web server listen address")
    parser.add_argument('--e2-web-port', metavar='PORT', type=int, default=8081,
        help="Web server port")
    parser.add_argument('--e2-web-static', metavar='PATH', default='static',
        help="Web server /static path")
    parser.add_argument('--e2-websocket-port', metavar='PORT', type=int, default=8082,
        help="WebSocket server port")
    parser.add_argument('--e2-presets-xml', metavar='PATH',
        help="Load presets from XML backup dump directory")
    parser.add_argument('--e2-presets-yaml', metavar='PATH', type=argparse.FileType('r'),
        help="Load presets from YAML")
    parser.add_argument('--e2-presets-db', metavar='PATH',
        help="Store preset state in db")
    
    # setup
    args = qmsk.cli.parse(parser, argv)
    loop = asyncio.get_event_loop()

    server = Server(loop)

    # start
    do_start = asyncio.async(server.start(args))

    try:
        log.info("start event loop")
        ret = loop.run_until_complete(do_start)

    except Exception as error:
        log.exception("Failed to start")
        return 1

    else:
        if ret:
            return ret

        log.info("startup complete")

    # run
    loop.add_signal_handler(signal.SIGINT, signal_stop, server)

    try:
        log.info("enter event loop")
        loop.run_forever()

    except Exception as error:
        log.exception("Failed to start")
        return 1

    else:
        log.info("exit")
        return 0

if __name__ == '__main__':
    qmsk.cli.main(main)
